<!DOCTYPE HTML>
<!--
	Urban by TEMPLATED
	templated.co @templatedco
	Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
	<head>
		<title>Generic - Urban by TEMPLATED</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="subpage">

		<!-- Header -->
			<header id="header">
				<div class="logo"><a href="index.html">Urban <span>by TEMPLATED</span></a></div>
				<a href="#menu">Menu</a>
			</header>

		<!-- Nav -->
			<nav id="menu">
				<ul class="links">
					<li><a href="index.html">Home</a></li>
					<li><a href="#section2">Internships</a></li>
						<ul class="alt">
							<li><a href="internships_ANDI.html">National Agency for the Development of Investment</a></li>
							<li><a href="internships_ASSF.html"> Africa Health Services and Formations</a></li>
						</ul>
					<li><a href="#section1">Projects</a></li>
						<ul class="alt">
							<li><a href="project1.html"> Project 1</a></li>
							<li><a href="project2.html"> Project 2</a></li>
							<li><a href="project3.html"> Project 3</a></li>
						</ul>
					<li><a href="aboutMe.html">About Me</a></li>
					<li><a href="elements.html">Elements</a></li>
				</ul>
			</nav>

		<!-- Main -->
			<div id="main">

				<!-- Section -->
					<section class="wrapper">
						<div class="inner">
							<header class="align-center">
								<h1>Artificial Neural Network</h1>
								<p> Building an artificial neural network in C.</p>
							</header>
							<div class="flex flex-2">
								<div class="col col2">
									<h3>Suspendisse quis massa vel justo</h3>
									<p> To have a proper understanding of the basis of neural networks and be able to properly understand what I am writing when I use libraries such as TensorFlow or PyTorch in Python, I have decided to build an Artificial Neural Network in C. </p>

									<p> The first step to build the network is to define its constitution, choose the number of inputs that we are going to give to the network, the number of hidden nodes that are going to process, the inputs and the number of outputs that we are looking to have. Here we design it as simply as possible, with two inputs, six hidden nodes and one final output. </p>
									<pre><code>
	static const int numInputs = 2;
	static const int numHiddenNodes = 6;
	static const int numOutputs = 1;
									</code></pre>
									<p> Our second step is to create a shuffling function to make sure that each data point that we feed to our model will not be affected and influenced by the points before. This way the impact on the weights of the model will bring more consistent results. To write the shuffling function we use the random generation of numbers with the math.h built in package. 
									</p>
									<pre><code>
	void shuffle (int *array, size_t n) {
	    if (n > 1) {
	        size_t i;
	        for (i = 0; i < n-1; i++) {
	            size_t j = i + rand() / (RAND_MAX / (n-i) + 1);
	            int t = array[j];
	            array[j] = array[i];
	            array[i] = t;
	        }
	    }
	}
									</code></pre>
									<p> To avoid that weights have similar value, to break its symmetry, we write two more methods. The first one is deisgned to generate random weights and the second one to set the value of the hidden nodes with these. <p />
									<pre><code>
	float randomWeights(float lower, float upper) {
	    float randomNum = lower + rand() / (RAND_MAX / (upper - lower+1)+1.0);
	    float weights = randomNum*sqrt(2.0/upper);
	    return weights;
	}

	void randomWeightsInitialisation(float arr[numInputs][numHiddenNodes]) {
	    for (int i = 0; i < numInputs; i++) {
	        for (int j = 0; j < numHiddenNodes; j++) {
	            float randomNum = randomWeights(2.0, 4.0);
	            arr[i][j] = randomNum;
	        }
	    }
	}
									</code></pre>
									<p> Before starting the main part of the program, we need to define the activation functions that we are going to use to train the model. To achieve that we are going to build a Sigmoid function and its derivative. This way the hidden neurones won't be perceptrons anymore but will become Sigmoid neurons. With this function each step of the process will be much smoother and the values kept between 0 and 1, to calculate probabilities the sigmoid is proper option for a small model like this one. The derivative will be helpful to convert the values to a more understandable state. </p>
									<pre><code>
	float sigmoid(float x) {
	    return 1/(1+exp(-x));
	}

	float dSigmoid(float x) {
	    return x * (1 - x);
	}
									</code></pre>
									<p> After defining all the necessary methods, we can start building the main block and defining the actual topology that our network is going to have. Our network will contain two layers with hidden nodes and an output layer. We are keeping it simple, our goal here is not to reinvent the wheel but just to understand the process. Each layer will be constituted by hidden neurones and along with its on layer for the biases and weights. 
										The weights will decide how much impact the input will have on the outcome of the network. 
										The bias are just here to make sure that the activation takes place within the neurones.

										And we don't forget to initialise the weights randomly with our beautiful methods defined previously!!</p>
									<pre><code>
    float outputLayer[numOutputs];
    float hiddenLayer_2[numHiddenNodes];
    float hiddenLayer[numHiddenNodes];
    
    float outputLayerBias[numOutputs];
    float hiddenLayerBias_2[numHiddenNodes];
    float hiddenLayerBias[numHiddenNodes];
    
    float outputWeights[numHiddenNodes][numOutputs];
    float hiddenWeights_2[numInputs][numHiddenNodes];
    float hiddenWeights[numInputs][numHiddenNodes];
    
    randomWeightsInitialisation(hiddenWeights_2);
    randomWeightsInitialisation(hiddenWeights);
									</code></pre>
									<p> We can then define what we are going to train our network on. Here we will state very simple values for a supervised training. 8 binary values in total and 4 outputs. You can see that only when there is one of the two values being a 1 that the output will also be a 1.</p>
									<pre><code>
    // Training set definition
    float training_inputs[4][2] = {
        {0.0f,0.0f},
        {1.0f,0.0f},
        {0.0f,1.0f},
        {1.0f,1.0f}
    };
    
    float training_outputs[4][1] = {
        {0.0f},
        {1.0f},
        {1.0f},
        {0.0f}
    };
									</code></pre>
									<p> For the next part, we are going to set a loop for a number of epochs and within a loop going through every element of the training set. For each element, three main steps are going to be applied: the computation of the activation, the computation of the changes in weights and the application of thoses changes to the weights. These three steps are going to be applied for each of the three layers. 
										Let see the first step, the computation of the activation. </p>
									<pre><code>
    // Compute hidden layer activation LAYER 1
    for (int j = 0; j < numHiddenNodes; j++) {
        float activation = hiddenLayerBias[j];
        for (int k = 0; k < numInputs; k++) {
            activation += training_inputs[i][k]*hiddenWeights[k][j];
        }
        hiddenLayer[j] = sigmoid(activation);
    }
    
    // Compute hidden layer activation LAYER 2
    for (int j = 0; j < numHiddenNodes; j++) {
        float activation2 = hiddenLayerBias_2[j];
        for (int k = 0; k < numInputs; k++) {
            activation2 += training_inputs[i][k]*hiddenLayer[j]*hiddenWeights_2[k][j];
        }
        hiddenLayer_2[j] = sigmoid(activation2);
    }
    
    // Compute output layer activation
    for (int j = 0; j < numOutputs; j++) {
        float activation = outputLayerBias[j];
        for (int k = 0; k < numHiddenNodes; k++) {
            activation += outputWeights[k][j]*hiddenLayer_2[k];
        }
        outputLayer[j] = sigmoid(activation);
    }
									</code></pre>
									<p> The changes in weights are then computed for each inputs being through the activation function, here the sigmoig activation (you can see the detail of the function above). For each changes, the error is calculated to correct the weights on the next epoch. 
									</p>
									<pre><code>
    // Compute change in output weights
    float deltaOutput[numOutputs];
    for (int j = 0; j < numOutputs; j++) {
        float dError = (training_outputs[i][j]-outputLayer[j]);
        deltaOutput[j] = dError*dSigmoid(outputLayer[j]);
        printf("Num output: %d", j);
        printf(" - [ERROR RATE]: %f\n", fabs(dError));
        
    }
    
    // Compute change in hidden weights LAYER 2
    float deltaHidden_2[numHiddenNodes];
    for (int j = 0; j < numHiddenNodes; j++) {
        float dError = 0.0f;
        for (int k = 0; k < numOutputs; k++) {
            dError += deltaOutput[k]*outputWeights[j][k];
            
        }
        deltaHidden_2[j] = dError*dSigmoid(hiddenLayer_2[j]);
    }
    
    // Compute change in hidden weights LAYER 1
    float deltaHidden[numHiddenNodes];
    for (int j = 0; j < numHiddenNodes; j++) {
        float dError = 0.0f;
        for (int k = 0; k < numOutputs; k++) {
            dError += deltaOutput[k]*outputWeights[j][k]*deltaHidden_2[j];
        }
        deltaHidden[j] = dError*dSigmoid(hiddenLayer[j]);
    }
									</code></pre>
									<p> And finally, the application of the changes computed before to the weights. 
									</p>
									<pre><code>
    // Apply change in output weights
    float lr = 0.1;
    for (int j = 0; j < numOutputs; j++) {
        outputLayerBias[j] += deltaOutput[j]*lr;
        for (int k = 0; k < numHiddenNodes; k++) {
            outputWeights[k][j] += hiddenLayer[k]*hiddenLayer_2[k]*deltaOutput[j]*lr;
        }
    }
    
    // Apply change in hidden weights LAYER 2
    for (int j = 0; j < numHiddenNodes; j++) {
        hiddenLayerBias_2[j] += deltaHidden[j]*lr;
        for(int k = 0; k < numInputs; k++) {
            hiddenWeights_2[k][j] += training_inputs[i][k]*deltaHidden_2[j]*lr;
        }
    }
    
    // Apply change in hidden weights LAYER 1
    for (int j = 0; j < numHiddenNodes; j++) {
        hiddenLayerBias[j] += deltaHidden[j]*lr;
        for(int k = 0; k < numInputs; k++) {
            hiddenWeights[k][j] += training_inputs[i][k]*deltaHidden[j]*lr;
        }
    }
									</code></pre>
									
									<p> This project allowed me in the first place to learn the syntax of a new language, the C and at the same time learn more about the fundations of neural network.</p>
								</div>
								<div class="col col1 first">
									<div class="image round fit">
										<a href="generic.html" class="link"><img src="images/pic02.jpg" alt="" /></a>
									</div>
								</div>
							</div>
							<p>Curabitur venenatis lorem ut finibus finibus. Ut quis eleifend libero, nec ultricies metus. Morbi magna risus, congue sit amet pellentesque eget, malesuada ut justo. Sed ac pretium quam. Ut vel ex vitae enim sagittis posuere ac id erat. Vestibulum vel ullamcorper tellus. Donec sapien massa, venenatis ac felis vel, vestibulum sagittis enim. Maecenas ut egestas lorem, nec luctus ligula. Vestibulum neque diam, aliquet non enim a, cursus lacinia metus. Aenean fringilla luctus rhoncus. Integer vulputate massa ac suscipit venenatis. Integer luctus elit non nulla fringilla, ullamcorper maximus sem congue. Integer tristique eu nisi nec fermentum. Ut malesuada quis massa at ultricies.</p>
							<p>Donec molestie tellus eu tincidunt dignissim. Sed sollicitudin bibendum ultricies. Vivamus tristique justo lacinia dui tempus consequat. Sed hendrerit justo in nisl auctor, id rutrum tortor congue. Vivamus mattis nibh et sem rutrum, vel viverra purus viverra. Donec et justo at orci euismod hendrerit vel vel neque. Donec gravida ipsum in augue volutpat laoreet. Ut lobortis turpis sit amet sodales ultrices.</p>
						</div>
					</section>

				<!-- Section -->
					<section class="wrapper style1">
						<div class="inner">
							<header class="align-center">
								<h2>Aliquam ipsum purus dolor</h2>
								<p>Cras sagittis turpis sit amet est tempus, sit amet consectetur purus tincidunt.</p>
							</header>
							<div class="flex flex-3">
								<div class="col align-center">
									<div class="image round fit">
										<img src="images/pic03.jpg" alt="" />
									</div>
									<p>Sed congue elit malesuada nibh, a varius odio vehicula aliquet. Aliquam consequat, nunc quis sollicitudin aliquet. </p>
									<a href="#" class="button">Learn More</a>
								</div>
								<div class="col align-center">
									<div class="image round fit">
										<img src="images/pic05.jpg" alt="" />
									</div>
									<p>Sed congue elit malesuada nibh, a varius odio vehicula aliquet. Aliquam consequat, nunc quis sollicitudin aliquet. </p>
									<a href="#" class="button">Learn More</a>
								</div>
								<div class="col align-center">
									<div class="image round fit">
										<img src="images/pic04.jpg" alt="" />
									</div>
									<p>Sed congue elit malesuada nibh, a varius odio vehicula aliquet. Aliquam consequat, nunc quis sollicitudin aliquet. </p>
									<a href="#" class="button">Learn More</a>
								</div>
							</div>
						</div>
					</section>

			</div>

		<!-- Footer -->
			<footer id="footer">
				<div class="copyright">
					<ul class="icons">
						<li><a href="#" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
						<li><a href="#" class="icon fa-facebook"><span class="label">Facebook</span></a></li>
						<li><a href="#" class="icon fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="#" class="icon fa-snapchat"><span class="label">Snapchat</span></a></li>
					</ul>
					<p>&copy; Untitled. All rights reserved. Design: <a href="https://templated.co">TEMPLATED</a>. Images: <a href="https://unsplash.com">Unsplash</a>.</p>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>